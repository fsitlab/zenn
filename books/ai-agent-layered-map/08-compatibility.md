---
title: "相性問題の発生箇所：5層モデルによる整理"
---

# 相性問題の発生箇所：5層モデルによる整理

> **元記事の対応章**: 第12章（全体俯瞰：「相性問題」はどこで起きるか）
> **追記 or 変更**: 変更（3層モデル→5層モデルへ拡張）
> **理由**: 4層モデル（追記A改訂版）にエージェント間通信層を加えた5層構造により、相性問題の発生箇所をより精密に特定できる。

---

## 5層モデル

```
第5層：UI・運用層              ユーザーとの接点（UI）+ LLMに直接関係しない周辺機能
                               例: VSCode / Claude.ai / 監視 / ログ分析 / ユーザー管理

第4層：外部ツール層            ベクトルDB、MCPサーバー、サブエージェント
                               例: Pinecone / MCPサーバー / A2Aエージェント

第3層：LLMオーケストレーション層  直接LLMとやり取りする層
                               例: ワークフロー / Hooks / MCPクライアント / エージェントランタイム

第2層：通信層                  A: クライアント起点（プロンプト、ツール宣言）
                               B: LLM起点（ツール利用判断、レスポンス）

第1層：LLM層                   モデル、パラメータ、JSON構造
                               例: Claude / GPT / LoRA / temperature
```

---

## 相性問題マッピング表（5層版）

| # | 相性問題 | 発生層 | 原因 | 対策 |
|---|----------|--------|------|------|
| 1 | APIフォーマット不一致（arguments文字列化等） | 第1層 | ベンダー間でtool引数形式が異なる（OpenAI=文字列、Anthropic=オブジェクト） | LiteLLM等の統一ラッパー使用 / 変換処理の明示実装 |
| 2 | tool descriptionが貧弱 | 第2層A | LLMはdescriptionを読んで「いつ使うか」を判断するため、曖昧な説明→ツール未使用・誤用 | description設計のベストプラクティス適用 / 評価フィードバック |
| 3 | モデルがtool use未学習 | 第1層 | OSSモデルがtool useをfine-tuneされていない | tool use対応モデルの選択 / fine-tuning実施 |
| 4 | ライブラリのバージョンとAPIのズレ | 第1層↔第3層 | LangChain等のラッパー層の更新遅れで新パラメータが使えない | APIを直接叩いて検証 / ライブラリ更新追従 |
| 5 | HookがPermissionより弱い認識 | 第3層 | PreToolUseは第2層AのCLAUDE.mdより優先度が高いことの理解不足 | 「第3層は第2層より上位」の設計原則理解 |
| 6 | MCPスキーマ不正 | 第3層↔第4層 | MCPサーバー実装のJSONスキーマ誤り→LLMが正しく呼べない | スキーマバリデーション / 公式SDKの利用 |
| 7 | CLAUDE.mdが巨大すぎる | 第2層A | コンテキスト汚染・優先度喪失・Context Window圧迫 | Skillへの分割（Progressive Disclosure） / 階層化 |
| 8 | Skillのdescriptionが曖昧 | 第2層A | 自動マッチ失敗（LLMが適切なSkillを選択できない） | description設計の精緻化 / テストによる検証 |
| 9 | 従来RAGとTool型RAGの混同 | 第2層A↔第2層B | LLMの視点で「2層Aの文書注入」と「2層Bのtool_use」は全く別物 | RAG方式の明確な選択 / LLMへの文脈説明 |
| 10 | Subagentのtools制限が甘い | 第3層↔第4層 | Subagentに過剰な権限を与えセキュリティリスク発生 | `tools`/`disallowedTools`の明示設定 / 最小権限原則 |
| 11 | フレームワーク間Agent通信（A2A未対応） | 第4層 | 異なるフレームワーク間でAgent通信プロトコルが統一されていない | A2Aプロトコル対応 / AgentCore等の統一基盤採用 |

---

## 層別の相性問題詳細

### 第1層・第2層（LLM層・通信層）の問題（#1, #2, #3）

**本質**: LLMはJSONを受け取り、JSONを返すだけ。この層の問題は「フォーマットの差異」と「モデルの能力限界」に起因する。

| 問題 | 具体例 | 検出方法 |
|------|--------|----------|
| #1 APIフォーマット不一致 | OpenAI: `arguments: "{\"city\":\"Tokyo\"}"` (文字列) / Anthropic: `input: {"city":"Tokyo"}` (オブジェクト) | mitmproxyでAPIコール傍受 |
| #2 description貧弱 | `"description": "天気を取得"` → いつ使うか不明 | ツール選択率の評価 |
| #3 tool use未学習 | Ollama上のOSSモデルがtool_useを返さない | 単体テストでtool_use呼び出し確認 |

**対策の共通原則**: APIを直接叩いて動作確認。フレームワークの抽象化に頼りすぎない。

---

### 第1層↔第3層 層間境界の問題（#4, #6, #9, #10）

**本質**: 第1層（LLM層）と第3層（LLMオーケストレーション層）の境界で「誰が何を変換・検証するか」の責任があいまいになる。

| 問題 | 責任の所在 | 解決パターン |
|------|------------|--------------|
| #4 ライブラリ版ズレ | 第3層（ライブラリ）が第1層の最新仕様に追従していない | APIを直接叩いて検証→ライブラリにパッチ or 乗り換え |
| #6 MCPスキーマ不正 | 第4層（MCPサーバー）が第2層Aに渡すJSONスキーマが不正 | MCP公式SDKでスキーマ生成 / バリデーション強化 |
| #9 RAG混同 | 第3層（ホスト）が第2層Aに注入するか、第2層Bのtool_resultで返すかの選択 | 設計時に「検索の主体は誰か」を明確化 |
| #10 Subagent権限 | 第3層（ホスト）がSubagentに渡す第2層Aのtools[]を適切に制限していない | `disallowedTools`の明示設定 |

**対策の共通原則**: 層間のインターフェースを明文化し、境界責任を設計ドキュメントに記載。

---

### 第3層（LLMオーケストレーション層）の問題（#5）

**本質**: プログラムが「必ず実行する」を保証する層。第2層A（プロンプト）より上位であることの理解不足。

```
優先度: 第3層 Hooks (PreToolUse) > 第2層A CLAUDE.md > LLMの判断
```

| 問題 | 誤解 | 正しい理解 |
|------|------|------------|
| #5 Hook < Permission認識 | 「CLAUDE.mdに書いたから安全」 | PreToolUseは第3層でありCLAUDE.md（第2層A）より優先度が高い。exit 2で確実にブロック可能 |

**対策**: Hooksの設計意図（決定論的制御）を理解し、セキュリティ要件はHooksで担保。

---

### 第2層A（プロンプト）の問題（#7, #8）

**本質**: 「言葉」で動作を制御する層。確率的であり、長すぎると優先度が不明確になる。

| 問題 | 症状 | 対策 |
|------|------|------|
| #7 CLAUDE.md巨大化 | LLMが指示を無視 / 重要な指示が埋もれる | Skillへ分割（Progressive Disclosure）/ `@import`で階層化 |
| #8 Skill description曖昧 | 適切なSkillが自動ロードされない | `name` + `description`を100トークン以内で明確に |

**Context Window制約との関係**:
- claude-sonnet-4-6: 200K tokens
- 巨大なCLAUDE.md + 多数のSkill全文ロード → Context圧迫 → 性能劣化

**対策**: Skillは「name + description」のみ起動時ロード、本文は必要時にロード（遅延ロード）。

---

### 第4層（外部ツール層）のエージェント間通信問題（#11）

**本質**: 異なるフレームワーク/ベンダー間でAgent同士が通信する際のプロトコル不統一。

| 通信方式 | 対応フレームワーク | 制約 |
|----------|-------------------|------|
| tool_result（ファイル共有） | ClaudeCode Teams | 同一マシン限定 |
| A2A JSON-RPC 2.0 | AgentCore / Google ADK | クラウドスケール対応 |

**現状の相互運用性**:
```
LangChain Agent ←→ Strands Agent: 直接通信不可（A2A未対応の場合）
ClaudeCode ←→ OpenAI Codex: ファイル共有のみ
AgentCore ←→ Google ADK: A2A対応で相互運用可能
```

**対策**:
- A2A対応フレームワークの採用（AgentCore / Google ADK）
- 中間層としてMCPサーバーを経由（各AgentがMCPクライアントとして動作）

---

## 相性問題の診断フローチャート

```
問題が発生
    │
    ├─ LLMがツールを呼ばない/誤った呼び方
    │      └→ #2 description確認 / #3 モデルのtool use対応確認
    │
    ├─ ツール呼び出し後のエラー
    │      └→ #1 APIフォーマット確認（mitmproxy）/ #6 MCPスキーマ検証
    │
    ├─ ライブラリ経由で動かない
    │      └→ #4 ライブラリ版確認 / API直接叩きで切り分け
    │
    ├─ セキュリティ制御が効かない
    │      └→ #5 Hooks設定確認 / #10 Subagent権限確認
    │
    ├─ LLMが指示を無視する
    │      └→ #7 CLAUDE.mdサイズ確認 / #8 Skill description確認
    │
    ├─ RAGの結果をLLMが活用しない
    │      └→ #9 従来RAG/Tool型RAGの選択確認
    │
    └─ 異なるフレームワーク間で通信できない
           └→ #11 A2A対応状況確認
```

---

## 層別の責任整理

| 層 | 責任 | 相性問題発生時の確認ポイント |
|----|------|------------------------------|
| 第1層 LLM層 | モデル能力 / パラメータ | モデルのtool use対応確認 |
| 第2層 通信層 | JSONフォーマット準拠 / プロンプト設計 | APIを直接叩いて動作確認 / CLAUDE.mdサイズ |
| 第3層 LLMオーケストレーション層 | Tool実行 / 権限管理 / スキーマ変換 | Hooks設定 / MCPサーバー実装 |
| 第4層 外部ツール層 | 外部リソース / Agent間通信 | A2A対応状況 / 通信方式の選択 |
| 第5層 UI・運用層 | ユーザーインターフェース / 周辺機能 | フレームワーク選択 / 設定ファイル |

---

## 参照

- 元記事 第12章「全体俯瞰：『相性問題』はどこで起きるか」
- 追記A改訂版「4層モデルと技術要素マスターマッピング表」
- Anthropic "Building Effective Agents"
- Chip Huyen "Agents"
- Hamel Husain "FU, Show Me The Prompt" (mitmproxyによるAPIコール傍受)

---

*作成日: 2026-02-22*
*対象: 骨子バージョン 2026-02-21 rev2 への差分*
