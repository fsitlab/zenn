本フォルダにある複数のMDファイルと統合して、1個の記事にしたい。ただし、１個のファイルへの出力は長くなりすぎるので、下に指定するよう、アウトプット用のパスに各章単位で分割したMDファイルを作成して。
ただし、これらのMDファイルのテイストを保ち、外部リンクを最大限活用しつつ、シンプルな説明で概念の整理を行いたい。



ただし、階層構造は以下に変更して、以下概念を追加したい。

1層:LLM 層 ファインチューニング、LoRAなど。 LoRAを使うとアダプタみたいに、ベースモデルにいろんな特徴を付与して業界ごとに最適化できる。

モデルの系列。 よくある出力ライブラリ。モデルによって、テキストのみ、画像、動画、対応範囲が異なる。

読めることと書けることは別。

モデルによってチューニングが異なり、Claudeは憲法があって信頼できるAIに

Googleはマルチモーダル、Antrhopic はAGIを目指すなど





2層:通信層 OpenAI APIや、Antrhopic API

旧１章の、プロトコルの違いや、SSE対応など。コンテンツに入れられるデータも異なるよね。

2層の通信として、A:クライアント起点 B:LLM起点 の2つがある。

Aの主なテクニックが、プロンプトチューニング。その他、ツール一覧を与えたり、　BではLLMがツールの利用を主体的に判断。



昔の１層は、今も１層のまま

旧２層（ツール層）が、今は２層B（LLM起点の通信）、　旧３層が、　今は２層A（クライアント起点の通信）　２層Bのツール利用については、２層Aでツールを宣言してから、みたいなことは補足して。



３層：アプリ層：LLMへの入力をコントロール

LangChain等のプログラム系、Dify等のローコード系、ChatGPTなどのコンシューマアプリ、ClaudeCode等のコーディングエージェント、Perplexityもここ。AWSだと、Strands Agentsが該当。AgentCoreは、AI Agentの機能を強化するメモリーなどの補助機能がそろっている。

それぞれ、系列ごとに有名なの名にあるか、名前だけ整理して。

従来型RAGで、ベクトル検索DBにクエリを投げて、プロンプトにチューニングする役割もここ。

ワークフローを作って、AI Agentを操ったりする。

LLMから、ツールを利用したいとの応答があれば、コードを実行したり、リモートＭＣＰサーバに中継したり、新たなAgentsを作成したりする。



4層：



４層：外部ツール層

ＲＡＧのベクトルＤＢや、リモートＭＣＰサーバ。　サブエージェントなんかも、

１層の指示で、２層Ａのツール利用支持がでて、３層のＣｌａｕｄｅＣｏｄｅがサブエージェント用立ち上げ支持を組み立て、④層の外部ツールとして、サブエージェントが実行される。

ツール利用で実際に動くプログラムなんかもここで良いかな。例えばローカルファイルを読み書きするプログラムなど

この層の位置は、a:クライアントのローカル環境　b:クライアントのサンドボックス環境　c:クラウド環境　など、いろんな場所が考えられる。サブエージェントなら、　クラウドAPIにLLMがいて、ツール利用でローカル環境のファイルを見えて、サンドボックス環境でプログラム実行なんかもあるかも。
また、内容も、α：ファイルの集合体（知識など）、β：プログラム、γ：ＡＩ等で分類できる
また、与える影響も、　CRUDで分類できる。時にローカル環境へのCUD、特にUDは危険なので、権限制御が重要。
ツールを利用しない場合、この層はない場合もある。

　



5層：プレゼンテーション層

３層と一緒になっていることも多いけど、Antigravityや、VsCodeなど、UI専用のサービスもあるかも。

この層はない場合もある。DifyはローコードでAgentを作れる。



＝＝＝

上記の階層構造にするけど、もともとの説明内容を減らさず元の説明はそれぞれ章として、維持して整合性だけ取って。この各層は、第１部、○○層みたいな感じにして。

早見表は、その規格がどの層に関係あるか、チェックして。複数層なら複数層。

例えばMCPの場合、LLM始点は見えないので１層は関係ないし、２層Bのツールの形式を決めているわけじゃなくて、３層と4層間のやりとりを定義してる。定義しているチェックと、利用影響があるチェックは別が良いかも。だって、MCPでLLMが使えないツールなら使えないので、１層２層も、MCPは定義していないが、影響があるので影響があるマークが必要だよね。でも、この影響があるは、利用可否、その主体の影響にして。例えばプロンプトチューニングは、せいぜい２層Aまでで、LLMによってプロンプト自体が使えなくなることはないし、３層や4層によって使えなくなることもないから、2層Aだけみたいな。従来RAGの主体は4層と３層で、2層Aを利用、LLM影響はなし。ツール型RAGは、4層、３層、2層A、２層B、１層まで影響する。ツールをそもそも使ってくれないのは、2層Aの渡し方が悪く、4層のツール自体や、1層のLLMが悪いわけじゃない、みたいな。

第１層から順に説明し、登場した段階でそのテクニックを書いて。

例えば、LoRAは第１層、　プロンプト工学・topKの指示、トークン指示は、第２層A、ツール利用は、第２層Aで宣言してから、BでLLMが利用。３層は、Claude.mdやスキルが該当するね。RAGは、１～４層使って動いてる。Agent Teamsモココかな。4層は内容が濃いです。AgentsやMCPやHook、等々たくさんの概念が出てくる。

Agentも、LLMが選択する場合して軌道と、３層のプログラウが選択して起動の両方がある。

第５層はDifyのワークフロー。

また、追加で以下内容もかいて。

＝＝

Claude Coworkが仕事をする仕組み。

ツール利用でスナップショットを受け取ることは分かったけど、デスクトップの操作は、どんなツールを利用してる？

どうやってここをクリック等の指示だしてる？RPAみたいに座標でだしてるの？それとも、CLIコマンドで操作してる？

Webブラウザ操作はPlayWrightみたいなの？革新ないからしらべて、これも章にして。

＝＝

## アウトプット形式
かなり長大なレポートになるので、アウトプットは章ごとにmdファイル分けて。

./work/ に、ワーク中の中間ファイルを保存して。
./work/memo.mdなどに、 各Agentが作業中に気づいた内容をメモファイルとして残して。
./work/plan.md に作業計画を残して。
成果物は、
./output/ に章ごとにMDファイルを分けて書いて。 

## タスクの進め方

Agent Teamsでタスクを処理して。
まずは、タスク計画を立てて。何をすべきか整理して。
また、制約事項を元に、./claudeをこの階層につくって、権限を書いて。
その後、並列可能な個所は並列処理して記事を書いて。
その後、ハルシネーションがないかチェックするエージェントは、嘘を検知して。
また、各章の整合性が取れているか、校閲するエージェントは校閲して。
検知した嘘や、校閲内容は、./work/review.mdなどにに保存して。
その後、この修正内容をみて、出力結果をブラッシュアップして。

## 制約事項
・元ファイルを編集してはいけない。新規ファイルを作成して。
・中間ファイルも削除は禁止。不要になったら、その階層に/oldフォルダを作ってそこに移動して。

### 記事のスタイル
元記事のスタイルを維持して。つまり、詳細な解説は外部記事や公式ページのリンクに投げて、
知識網羅と、知識の階層づけを意識する。
ただし、元記事にあるような、本記事で伝えたい理解を助ける図は、適宜マーメード図や表、箇条書きを駆使して伝えて。
本記事の目的は、いろんな個所で学んだ生成AIに関する概念がどの層に位置するかを明らかにして、知識を整理すること。
また、知識を整理することで、新しい技術の本質を知り、どんな革新があったか理解すること。
例えば、従来RAGとツール型RAGでは、仕組みが異なるので全然精度がかわる。
また、同じマルチエージェントでも、３層のプログラムがおーけストレートするAgentと、１層のLLM自身が、２層Bを通して呼ぶのでは全然違う。
このような構造で理解することが目標。


