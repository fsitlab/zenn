# 第4層「外部ツール層」詳細解説 (b) エージェント連携

> **シリーズ**: AIエージェント概念マップ詳細解説
> **対象層**: 第4層（外部ツール層）- エージェント連携編
> **関連章**: 元記事 第8章（Subagent）、第9章（Agent Teams）、04_外部ツール層.md

---

## 1. エージェント連携の概要

**一言**: 複数のAIエージェントが協調してタスクを遂行する仕組み。単一エージェントの限界を超え、専門化・並列化・異種連携を実現する。

### 1-1. エージェント連携の3つの方式

```mermaid
flowchart LR
    subgraph 方式["エージェント連携方式"]
        direction TB
        SA["サブエージェント<br/>（同期・階層的）"]
        AT["Agent Teams<br/>（非同期・並列）"]
        A2A["A2A<br/>（異種フレームワーク間）"]
    end

    SA --> |"tool_use/result"| 親子関係
    AT --> |"タスクボード"| チーム協働
    A2A --> |"JSON-RPC"| 異種連携
```

| 方式 | 通信方式 | 並列性 | 適用場面 |
|------|----------|--------|----------|
| **サブエージェント** | tool_use/tool_result | 複数子の順次/並列起動可能 | タスク委譲・専門処理 |
| **Agent Teams** | 内部タスクボード | 可能（非同期） | 複雑なプロジェクト |
| **A2A** | JSON-RPC 2.0 | 可能 | 異種フレームワーク間 |

### 1-2. 5層モデルにおける位置づけ

```
第5層 UI・運用層              ← ユーザーとの接点 + LLMに直接関係しない周辺機能
      ↑
第4層 外部ツール層            ← エージェント連携はここ
      │
      ├─ サブエージェント     ← 親から起動される子エージェント（複数可）
      ├─ Agent Teams         ← チームとして協働するエージェント群
      └─ A2Aエージェント      ← 異なるフレームワーク間で通信
      ↑
第3層 LLMオーケストレーション層  ← エージェントを起動・管理
```

---

## 2. AIエージェントの種類（連携パターン分類）

エージェント連携の方式を理解するには、AIエージェントのアーキテクチャパターンを把握することが重要です。

### 2-1. 5つの主要パターン

```mermaid
flowchart TB
    subgraph Patterns["AIエージェントの種類"]
        direction TB
        WF["Workflow型<br/>決められた手順に沿って動作"]
        TU["Tool Use型<br/>親Agentがツールを自発的に使用"]
        MO["Multi-Agent Orchestration型<br/>親Agentが他Agentをツールとして呼ぶ"]
        BB["Blackboard型<br/>共有ボードに書き込み"]
        MP["Message Passing型<br/>メールボックスにメッセージ送信"]
    end

    WF --> |"プログラム制御"| 固定フロー
    TU --> |"LLM判断"| 動的ツール選択
    MO --> |"LLM判断"| 他Agent呼出
    BB --> |"共有状態"| 非同期協調
    MP --> |"直接通信"| 分散処理
```

### 2-2. 各パターンの詳細

| パターン | 制御主体 | 通信方式 | 特徴 | 例 |
|----------|----------|----------|------|-----|
| **Workflow型** | プログラム | 固定フロー | 事前定義されたワークフローに沿って動作。LLMは各ステップで呼ばれる | CI/CDパイプライン、ETL処理 |
| **Tool Use型** | 親Agent（LLM） | tool_use/tool_result | 親Agentがプログラムやファイル等のツールを自発的に選択・使用 | Claude Code、GitHub Copilot |
| **Multi-Agent Orchestration型** | 親Agent（LLM） | tool_use/tool_result | 親Agentが他のAgentをツールとして呼び出す | サブエージェント、A2A |
| **Blackboard型** | 各Agent（自律） | 共有タスクボード | 共有ホワイトボードに情報を書き込み、他Agentが読み取る | Agent Teams |
| **Message Passing型** | 各Agent（自律） | メッセージキュー | 各Agentがメールボックスを持ち、非同期でメッセージを送受信 | Actor Model、MAS |

### 2-3. パターンとClaude Code機能の対応

```mermaid
flowchart LR
    subgraph ClaudeCode["Claude Codeでの実装"]
        direction TB
        TU2["Tool Use型"] --> Tools["Read, Write, Bash等"]
        MO2["Multi-Agent Orchestration型"] --> SubAgent["サブエージェント"]
        BB2["Blackboard型"] --> Teams["Agent Teams"]
    end
```

| Claude Code機能 | 対応パターン | 説明 |
|-----------------|--------------|------|
| ツール群（Read, Write, Bash等） | Tool Use型 | LLMが状況に応じてツールを選択 |
| サブエージェント（Task） | Multi-Agent Orchestration型 | 他Agentをツールとして呼び出し |
| Agent Teams | Blackboard型 | タスクボードを介した協調 |
| SendMessage | Message Passing型 | テイメイト間の直接通信 |

---

## 3. サブエージェント（SubAgent）

### 3-1. サブエージェントとは

**一言**: 親エージェントが特定タスクを委譲するために起動する子エージェント。親は子の完了を待つ（同期的）。**複数の子エージェントを順次または並列で起動可能**。

**Claude Codeでの実装**: `Task`ツールを使用して起動

```
親エージェント: 「この調査タスクはサブエージェントに任せよう」
  ↓ tool_use: Task（子エージェント1）
サブエージェント1: 独立したセッションで実行
  ↓ tool_result
親エージェント: 結果を受け取り、別のサブエージェントを起動
  ↓ tool_use: Task（子エージェント2）
サブエージェント2: 独立したセッションで実行
  ↓ tool_result
親エージェント: 全結果を統合して次の処理へ
```

### 3-2. サブエージェントのフロー（複数子エージェント）

```mermaid
sequenceDiagram
    participant User as 第5層<br/>ユーザー
    participant Parent as 第1〜3層<br/>親エージェント
    participant App as 第3層<br/>LLMオーケストレーション層
    participant Sub1 as 第4層<br/>サブエージェント1
    participant Sub2 as 第4層<br/>サブエージェント2

    User->>Parent: タスク依頼
    Parent->>Parent: タスク分析・分解

    Note over Parent: 「複数のサブエージェント<br/>に分担して委譲」

    Parent-->>App: tool_use: Task1（第2層B）
    App->>Sub1: サブエージェント1起動

    rect rgb(240, 248, 255)
        Note over Sub1: サブエージェント1独立稼働
        Sub1->>Sub1: タスク実行
    end

    Sub1-->>App: 実行結果1
    App->>Parent: tool_result（第2層A）

    Parent-->>App: tool_use: Task2（第2層B）
    App->>Sub2: サブエージェント2起動

    rect rgb(255, 248, 240)
        Note over Sub2: サブエージェント2独立稼働
        Sub2->>Sub2: タスク実行
    end

    Sub2-->>App: 実行結果2
    App->>Parent: tool_result（第2層A）

    Parent->>Parent: 結果統合
    Parent-->>User: 最終回答
```

### 3-3. サブエージェントの特徴

| 特徴 | 説明 |
|------|------|
| **同期実行** | 親は各子の完了を待つ（ブロッキング） |
| **複数子起動可能** | 順次または並列で複数のサブエージェントを起動可能 |
| **独立コンテキスト** | 各サブエージェントは独自のCLAUDE.mdをロード |
| **ツール制限継承** | 親の`allowedTools`/`disallowedTools`が継承される |
| **セッション分離** | 親の会話履歴はサブエージェントに渡らない |

### 3-4. サブエージェント定義ファイル

`.claude/agents/`ディレクトリにMarkdownファイルとして定義:

```yaml
# .claude/agents/code-reviewer.md
---
tools: Read, Glob, Grep          # 使用可能なツール
disallowedTools: Write, Bash     # 禁止ツール
model: claude-haiku-4-5          # 使用モデル（コスト最適化）
permissionMode: default          # 権限モード
hooks:                           # サブエージェント固有Hooks
  PreToolUse: ...
skills:                          # サブエージェント固有Skill
  - code-review-patterns
---
# system prompt本文
You are a code reviewer specializing in security vulnerabilities.
Always check for:
- SQL injection
- XSS
- Authentication bypass
```

### 3-5. サブエージェントのユースケース

| ユースケース | 説明 | 推奨設定 |
|--------------|------|----------|
| **コードレビュー** | セキュリティ観点の専門レビュー | `tools: Read, Glob, Grep` |
| **調査タスク** | 特定トピックの情報収集 | `tools: WebSearch, WebFetch` |
| **ファイル整理** | ドキュメント構造の再編成 | `tools: Read, Write, Glob` |
| **テスト実行** | 特定テストスイートの実行 | `tools: Bash(npm test*)` |

---

## 4. Agent Teams（チーム協働）

### 4-1. Agent Teamsとは

**一言**: 複数のエージェント（テイメイト）がタスクボードを共有し、並列で非同期に協働する仕組み。人間もチームメンバーとして参加可能。

**Claude Codeでの実装**: `/teams`コマンドで有効化

> **注意: 実験的機能**
> Agent Teamsは現在**実験的機能（experimental）**であり、デフォルトでは無効になっています。
>
> **有効化方法1: 環境変数**
> ```bash
> export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=true
> ```
>
> **有効化方法2: settings.json**
> ```json
> // .claude/settings.json
> {
>   "experimental": {
>     "agentTeams": true
>   }
> }
> ```
>
> 実験的機能のため、APIや動作が将来変更される可能性があります。

### 4-2. 組み込みサブエージェント

Claude Codeには、Agent Teamsとは別に、特定用途向けの**組み込みサブエージェント**が用意されています。

| サブエージェント | 用途 | 特徴 |
|------------------|------|------|
| **Explore** | コードベース探索 | 読み取り専用ツールのみ使用。コードの理解・調査に特化 |
| **Plan** | 計画立案 | タスクの分解・計画作成に特化。実行は行わない |

これらは`Task`ツールから呼び出す際に、専用のシステムプロンプトとツール制限が適用されます。

```typescript
// 使用例（内部的な呼び出しイメージ）
{
  "tool": "Task",
  "input": {
    "agent": "Explore",
    "task": "認証モジュールの構造を調査してください"
  }
}
```

### 4-3. Agent Teamsのフロー

```mermaid
sequenceDiagram
    participant User as 第5層<br/>ユーザー
    participant Lead as 第3層<br/>リードエージェント
    participant Board as 第4層<br/>タスクボード（共有状態）
    participant T1 as 第4層<br/>テイメイト1
    participant T2 as 第4層<br/>テイメイト2

    User->>Lead: タスク依頼
    Lead->>Board: タスク作成・分解

    par 並列実行
        T1->>Board: タスク取得
        T1->>T1: タスク実行
        T1->>Board: 結果報告
    and
        T2->>Board: タスク取得
        T2->>T2: タスク実行
        T2->>Board: 結果報告
    end

    Note over User,T2: 人間の割り込み可能
    User->>Board: 追加指示・優先度変更

    Lead->>Board: 進捗確認
    Lead->>Lead: 結果統合
    Lead-->>User: 最終回答
```

### 4-4. Agent Teamsの特徴

| 特徴 | 説明 |
|------|------|
| **非同期並列** | テイメイトが独立して並列実行 |
| **共有状態** | タスクボードで進捗・結果を共有 |
| **人間参加** | ユーザーがいつでも割り込み・指示変更可能 |
| **役割交代** | リード/テイメイトの役割は柔軟に交代可能 |
| **メッセージング** | `SendMessage`でテイメイト間通信 |

### 4-5. Agent Teamsの構成要素

```mermaid
flowchart TB
    subgraph AgentTeams["Agent Teams"]
        direction TB

        subgraph Roles["役割"]
            Lead["リード<br/>（オーケストレーター）"]
            Teammate1["テイメイト1<br/>（ワーカー）"]
            Teammate2["テイメイト2<br/>（ワーカー）"]
        end

        subgraph SharedState["共有状態"]
            Board["タスクボード"]
            Files["ファイルシステム"]
        end

        Lead --> Board
        Teammate1 --> Board
        Teammate2 --> Board
        Board --> Files
    end

    User["ユーザー"] -.->|割り込み| Board
```

### 4-6. テイメイト間通信

```typescript
// SendMessageの使用例
{
  "tool": "SendMessage",
  "input": {
    "target": "teammate-security-review",
    "message": "認証モジュールのレビューが必要です。優先度高。"
  }
}
```

### 4-7. Agent Teamsのユースケース

| ユースケース | 構成例 | 効果 |
|--------------|--------|------|
| **大規模リファクタリング** | リード1 + テイメイト3 | 並列でモジュール分担 |
| **コードレビュー** | セキュリティ + パフォーマンス + スタイル | 観点別の専門レビュー |
| **ドキュメント作成** | 調査 + 執筆 + レビュー | パイプライン処理 |
| **マイグレーション** | 分析 + 実装 + テスト | フェーズ別分担 |

---

## 5. A2A（Agent-to-Agent）プロトコル

### 5-1. A2Aとは

**一言**: Google発の標準化プロトコル。異なるフレームワーク間でエージェントが通信するためのHTTP/JSON-RPC 2.0ベースの仕様。

### 5-2. A2Aのフロー

```mermaid
sequenceDiagram
    participant Client as 第5層<br/>クライアント
    participant AgentA as 親Agent<br/>（第1〜3層内包）
    participant AgentB as 外部Agent B<br/>（第1〜4層内包）
    participant AgentC as 外部Agent C<br/>（第1〜4層内包）

    Note over AgentA: 親Agentは内部に<br/>第1層:LLM<br/>第2層:通信<br/>第3層:オーケストレーション<br/>を持つ
    Note over AgentB,AgentC: 外部Agentは独立したAIシステムとして<br/>第1〜4層を内包

    Note over AgentA,AgentC: 発見フェーズ
    AgentA->>AgentB: GET /.well-known/agent.json
    AgentB-->>AgentA: Agent Card（スキル一覧）
    AgentA->>AgentC: GET /.well-known/agent.json
    AgentC-->>AgentA: Agent Card（スキル一覧）

    Note over Client,AgentC: 実行フェーズ
    Client->>AgentA: タスク依頼
    AgentA->>AgentA: タスク分解

    par 並列実行
        AgentA->>AgentB: JSON-RPC: tasks/send
        AgentB-->>AgentA: 部分結果
    and
        AgentA->>AgentC: JSON-RPC: tasks/send
        AgentC-->>AgentA: 部分結果
    end

    AgentA->>AgentA: 結果統合
    AgentA-->>Client: 最終回答
```

> **補足: A2Aにおける層構造**
>
> A2Aでは、各Agentが独立したAIシステムとして第1〜4層を内包しています。
>
> - **親Agent（オーケストレーター）**: 第1層（LLM）、第2層（通信）、第3層（オーケストレーション）を持ち、外部Agentを第4層のツールとして呼び出します。
> - **外部Agent（ワーカー）**: 親Agentから見ると第4層に位置しますが、外部Agent内部では独自の第1〜4層が完全に存在します。つまり、外部Agentも自身のLLM、通信層、オーケストレーション層、さらには別の外部ツールを持つことができます。
>
> この構造により、A2Aは異種フレームワーク間での対等なエージェント連携を実現しています。

### 5-3. Agent Card（発見用メタデータ）

エージェントは`/.well-known/agent.json`でAgent Cardを公開:

```json
{
  "name": "DataAnalysisAgent",
  "description": "CSV/JSONデータの統計分析を行うエージェント",
  "url": "https://agent-b.example.com",
  "version": "1.0.0",
  "skills": [
    {
      "name": "analyze_csv",
      "description": "CSVファイルを統計分析する",
      "inputSchema": {
        "type": "object",
        "properties": {
          "file_url": {"type": "string"},
          "analysis_type": {"enum": ["summary", "correlation", "regression"]}
        }
      }
    },
    {
      "name": "generate_report",
      "description": "分析結果からレポートを生成する"
    }
  ]
}
```

### 5-4. Agent Cardの情報伝達経路

Agent Cardの情報がどのようにLLMに伝わるかを示します。

```mermaid
sequenceDiagram
    participant AC as Agent Card<br/>（/.well-known/agent.json）
    participant MCP as 第3層<br/>MCPクライアント
    participant Tools as 第2層B<br/>tools[]配列
    participant Layer2A as 第2層A<br/>応答解析
    participant LLM as 第1層<br/>LLM

    Note over AC,LLM: Agent Card情報の伝達経路

    AC->>MCP: HTTP GET<br/>Agent Card取得
    MCP->>MCP: Agent Cardをパース<br/>skillsをツール定義に変換

    MCP->>Tools: tools[]配列に追加<br/>（name, description, inputSchema）

    Note over Tools: ツール一覧として統合<br/>ローカルツール + 外部Agent

    Tools->>LLM: system promptに含めて送信<br/>Available tools: [...]

    LLM->>LLM: ツール一覧を理解<br/>適切なツールを選択

    LLM->>Layer2A: tool_use: analyze_csv
    Layer2A->>MCP: 外部Agentへの呼び出しと判定
    MCP->>AC: JSON-RPC: tasks/send
```

### 5-5. A2Aの特徴

| 特徴 | 説明 |
|------|------|
| **異種連携** | LangChain/AgentCore/ADK等の異なるフレームワーク間通信 |
| **標準プロトコル** | JSON-RPC 2.0 over HTTP/SSE |
| **発見機能** | Agent Cardによるスキル公開 |
| **クラウドスケール** | HTTP経由でリモートエージェントと通信 |

### 5-6. A2A対応フレームワーク

| フレームワーク | A2A対応状況 | 備考 |
|----------------|-------------|------|
| Amazon Bedrock AgentCore | 対応 | 公式サポート |
| Google ADK | 対応 | A2A策定元 |
| LangChain | 実装進行中 | コミュニティ主導 |
| Claude Code | 未対応 | Subagent/Teams使用 |

### 5-7. AgentCore構成要素

Amazon Bedrock AgentCoreの主要コンポーネントと、5層モデルにおける位置づけを示します。

| コンポーネント | 役割 | 層 |
|---------------|------|-----|
| Agent Runtime | エージェントの実行環境 | 第3層（LLMオーケストレーション層） |
| Tool Registry | 利用可能なツールの管理 | 第3層↔第4層の境界 |
| Memory Store | 会話履歴・状態の永続化 | 第4層（外部ツール層） |
| Cedar Engine | 認可ポリシーの評価 | 第3層（セキュリティ制御） |
| A2A Gateway | 外部エージェントとの連携 | 第4層（外部ツール層） |

---

## 6. 5層モデルでの通信方式

### 6-1. 各連携方式の通信経路図

```mermaid
flowchart TB
    subgraph Layer5["第5層 UI・運用層"]
        User["ユーザー"]
    end

    subgraph Layer4["第4層 外部ツール層"]
        SubAgent["サブエージェント"]
        Teammate["テイメイト"]
        A2AAgent["A2Aエージェント"]
        TaskBoard["タスクボード"]
    end

    subgraph Layer3["第3層 LLMオーケストレーション層"]
        App["アプリケーション<br/>（Claude Code等）"]
        MCP["MCPクライアント"]
    end

    subgraph Layer2["第2層 通信層"]
        Layer2B["第2層B: ツール実行要求"]
        Layer2A["第2層A: 応答解析"]
    end

    subgraph Layer1["第1層 LLM層"]
        LLM["LLM<br/>（Claude等）"]
    end

    %% ユーザーからの入力
    User -->|"入力"| App

    %% サブエージェント経路
    LLM -->|"tool_use: Task"| Layer2B
    Layer2B -->|"サブエージェント起動"| SubAgent
    SubAgent -->|"tool_result"| Layer2A
    Layer2A -->|"結果"| LLM

    %% Agent Teams経路
    App -->|"タスク登録"| TaskBoard
    TaskBoard <-->|"タスク取得/報告"| Teammate

    %% A2A経路
    MCP -->|"JSON-RPC"| A2AAgent
    A2AAgent -->|"JSON-RPC応答"| MCP

    style Layer5 fill:#e8f5e9
    style Layer4 fill:#fff3e0
    style Layer3 fill:#e3f2fd
    style Layer2 fill:#fce4ec
    style Layer1 fill:#f3e5f5
```

### 6-2. 通信経路の詳細比較

```mermaid
flowchart LR
    subgraph SubAgentPath["サブエージェント経路"]
        direction TB
        L1_SA["第1層: LLM"] --> L2B_SA["第2層B: tool_use: Task"]
        L2B_SA --> L3_SA["第3層: LLMオーケストレーション層"]
        L3_SA --> L4_SA["第4層: サブエージェント"]
        L4_SA --> L3_SA2["第3層: LLMオーケストレーション層"]
        L3_SA2 --> L2A_SA["第2層A: tool_result"]
        L2A_SA --> L1_SA2["第1層: LLM"]
    end

    subgraph TeamsPath["Agent Teams経路"]
        direction TB
        L5_AT["第5層: ユーザー"] --> L3_AT["第3層: リード"]
        L3_AT --> L4_AT["第4層: タスクボード"]
        L4_AT <--> L4_AT2["第4層: テイメイト群"]
    end

    subgraph A2APath["A2A経路"]
        direction TB
        L1_A2A["第1層: LLM"] --> L2B_A2A["第2層B: tool_use"]
        L2B_A2A --> L3_A2A["第3層: MCPクライアント"]
        L3_A2A --> L4_A2A["第4層: A2Aエージェント<br/>（HTTP/JSON-RPC）"]
        L4_A2A --> L3_A2A2["第3層: MCPクライアント"]
        L3_A2A2 --> L2A_A2A["第2層A: tool_result"]
        L2A_A2A --> L1_A2A2["第1層: LLM"]
    end

    style SubAgentPath fill:#e1f5fe
    style TeamsPath fill:#f3e5f5
    style A2APath fill:#e8f5e9
```

### 6-3. 層別の役割と通信

| 層 | サブエージェント | Agent Teams | A2A |
|----|------------------|-------------|-----|
| **第5層（UI・運用層）** | ユーザー入力 | ユーザー入力・割り込み | ユーザー入力 |
| **第4層** | サブエージェント実行 | タスクボード・テイメイト | A2Aエージェント（リモート） |
| **第3層（LLMオーケストレーション層）** | 起動・管理 | リード・タスク管理 | MCPクライアント・JSON-RPC |
| **第2層B** | tool_use: Task | - | tool_use（Agent呼出） |
| **第2層A** | tool_result | - | tool_result |
| **第1層** | 判断・統合 | - | 判断・統合 |

---

## 7. 3方式の比較

### 7-1. 構造比較図

```mermaid
flowchart TB
    subgraph SubAgent["サブエージェント（同期・複数子可）"]
        direction LR
        P1[親] -->|tool_use| S1[子1]
        P1 -->|tool_use| S2[子2]
        S1 -->|tool_result| P1
        S2 -->|tool_result| P1
    end

    subgraph AgentTeams["Agent Teams（非同期・並列・共有状態）"]
        direction TB
        L[リード] --> B[タスクボード]
        B --> T1[テイメイト1]
        B --> T2[テイメイト2]
        T1 --> B
        T2 --> B
        U[ユーザー] -.->|割り込み| B
    end

    subgraph A2A["A2A（異種フレームワーク間）"]
        direction LR
        O[オーケストレーター] -->|JSON-RPC| W1[ワーカーA<br/>LangChain]
        O -->|JSON-RPC| W2[ワーカーB<br/>AgentCore]
    end

    style SubAgent fill:#e1f5fe
    style AgentTeams fill:#f3e5f5
    style A2A fill:#e8f5e9
```

### 7-2. 詳細比較表

| 観点 | サブエージェント | Agent Teams | A2A |
|------|------------------|-------------|-----|
| **通信方式** | tool_use/tool_result | 内部タスクボード | JSON-RPC 2.0 |
| **並列実行** | 可能（複数子を順次/並列起動） | 可能（非同期） | 可能 |
| **エージェント間通信** | 親経由のみ | SendMessage | tasks/send |
| **人間の割り込み** | セッション停止のみ | いつでも可能 | 実装依存 |
| **状態共有** | なし | タスクボード | なし（メッセージベース） |
| **フレームワーク制約** | 同一（Claude Code） | 同一（Claude Code） | 異種間可能 |
| **スケーラビリティ** | 複数子エージェント | チーム規模 | クラウドスケール |

### 7-3. 選択ガイド

```mermaid
flowchart TD
    Start["エージェント連携が必要"] --> Q1{"異なるフレームワーク間<br/>で連携が必要？"}

    Q1 -->|Yes| A2A["A2Aを使用"]
    Q1 -->|No| Q2{"複数タスクを<br/>非同期並列実行したい？"}

    Q2 -->|Yes| Q3{"人間の割り込みが<br/>必要？"}
    Q2 -->|No| SubAgent["サブエージェントを使用<br/>（複数子も可）"]

    Q3 -->|Yes| AgentTeams["Agent Teamsを使用"]
    Q3 -->|No| Q4{"共有状態で<br/>協調が必要？"}

    Q4 -->|Yes| AgentTeams
    Q4 -->|No| SubAgent_Multi["複数サブエージェント<br/>（順次/並列実行）"]
```

---

## 8. 実装パターン

### 8-1. Orchestrator-Workers パターン

**概要**: 1つのオーケストレーターが複数のワーカーにタスクを分配

```mermaid
flowchart TB
    Orch["オーケストレーター<br/>（タスク分解・統合）"]

    Orch --> W1["ワーカー1<br/>調査"]
    Orch --> W2["ワーカー2<br/>実装"]
    Orch --> W3["ワーカー3<br/>テスト"]

    W1 --> Orch
    W2 --> Orch
    W3 --> Orch
```

**適用場面**:
- 大規模なタスクを分割して並列処理
- 専門性の異なるサブタスクの組み合わせ

### 8-2. Pipeline パターン

**概要**: タスクを順次処理するパイプライン

```mermaid
flowchart LR
    A1["エージェント1<br/>データ収集"] --> A2["エージェント2<br/>分析"]
    A2 --> A3["エージェント3<br/>レポート生成"]
```

**適用場面**:
- 前工程の出力が後工程の入力になる処理
- 品質ゲートを挟む処理フロー

### 8-3. Evaluator-Optimizer パターン

**概要**: 生成と評価を繰り返して品質を向上

```mermaid
flowchart TB
    Gen["生成エージェント"] --> Eval["評価エージェント"]
    Eval -->|"品質不足"| Gen
    Eval -->|"品質OK"| Output["最終出力"]
```

**適用場面**:
- コード品質の反復改善
- ドキュメントの推敲

---

## 9. セキュリティと権限管理

### 9-1. サブエージェントの権限制御

```yaml
# 親の設定
disallowedTools: ["Bash", "Write"]

# → サブエージェントも自動的に Bash, Write が禁止される
```

### 9-2. Agent Teamsの権限分離

```yaml
# テイメイトごとに異なる権限設定
# .claude/agents/read-only-reviewer.md
---
tools: Read, Glob, Grep
disallowedTools: Write, Bash, Edit
---
```

### 9-3. A2Aのセキュリティ

| セキュリティ要素 | 実装方法 |
|------------------|----------|
| **認証** | OAuth 2.0 / API Key |
| **認可** | Agent Cardでスキル範囲を公開 |
| **通信暗号化** | HTTPS必須 |
| **入力検証** | JSON Schemaによるバリデーション |

---

## 10. 相性問題と注意点

### 10-1. よくある問題

| 問題 | 原因 | 対策 |
|------|------|------|
| サブエージェントが指示を無視 | プロンプトが曖昧 | 明確なタスク記述 |
| Agent Teamsで競合 | 同一ファイルへの同時編集 | タスク分割の見直し |
| A2Aで接続失敗 | Agent Card未公開 | `/.well-known/`設定確認 |
| 権限エラー | 親からの継承制限 | `allowedTools`設定確認 |

### 10-2. デバッグのポイント

1. **サブエージェント**: `--verbose`フラグでtool_use/tool_resultを確認
2. **Agent Teams**: タスクボードの状態を直接確認
3. **A2A**: HTTPリクエスト/レスポンスのログ確認

---

## 11. 参考リンク

### 公式ドキュメント
- [Claude Code Sub-agents](https://code.claude.com/docs/en/sub-agents)
- [Claude Code Agent Teams](https://code.claude.com/docs/en/agent-teams)
- [Google A2A プロトコル仕様](https://google.github.io/A2A/)
- [Amazon Bedrock AgentCore](https://aws.amazon.com/bedrock/agentcore/)

### 解説記事
- [Anthropic "Building Effective Agents"](https://www.anthropic.com/research/building-effective-agents) — Orchestrator-Workers パターン
- [Chip Huyen "Agents"](https://huyenchip.com/2025/01/07/agents.html) — Multi-Agent Systems

---

*作成日: 2026-02-22*
*シリーズ: AIエージェント概念マップ詳細解説*
*参照: 元記事 第8章（Subagent）、第9章（Agent Teams）*
